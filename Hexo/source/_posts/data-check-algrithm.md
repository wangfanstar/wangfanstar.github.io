---
title: 用算法实现数据校验
category: 编程
date: 2018-05-01 17:47:25
tags: 算法
---

## 数据校验的作用

在数据传输的过程中，很多时候会有干扰，导致接收方的数据与发送方的数据不一致。这样就得进行数据重传或纠错等处理，例如TCP/IP协议中就有发现数据接收错误就会要求重传数据包等机制。接收方如何判断数据是否被破坏呢，这就需要数据校验算法来实现了。

## 数据校验算法的需求

- 尽可能少的时间复杂度和空间复杂度，让接收方能尽快完成校验以免影响正常数据传输速率
- 准确率必须达到一定值，如果校验出错肯定是有错，校验不出错可能有错。

## 数据校验位的实现

下面介绍一种简单的数据校验算法，此算法广泛地应用在TCP/IP协议中，在TCP/IP的数据包中，一般有一个16b的数据校验位，利用这个16b的空间和一个简单的校验算法，可以很快地求出接收方数据是否有误，具体实现如下：

假设一个数据包的大小是20Byte,即160b(包括16b的校验位)，其数据的位数为160b-16b =144b，此算法的原理如下，在发送方构造 一个16b的校验位，使得所有160b数据在按16b相加后得到的数据为全F(或全0），接收方在收到数据后也按16b一组进行相加，如果收到的数据是全F，则说明数据正常，否则校验失败，判断数据有误，让发送方进行重发处理。

构造此算法考虑到以下几点：

1. 考虑到加法有进位，当有进位时采取进位重新加到最低位的处理方法

2. 发送方将144b先进行16b一组的加法处理后，得到一个16b的数据，根据正码+反码=全F的特性，可以将此16b的校验大小设置成得到数据后的反码。

   下面用C语言进行实现，（初始校验码全为0）数据假设为BUF, 大小为SIZE，计算出的校验位为16b 的 校验码

   ```c
   #include <stdio.h>
   #include <stddef.h>
   unsigned short CheckSum(void * Buf, size_t Size)
   {
     unsigned short CheckCode = 0;
     unsigned long sum = 0;
     unsigned short * p = Buf;
     while(Size > 1)
     {
       sum += *p;
         p++;
       Size = Size - 2;
     }
     
     /* 如果数据大小非偶数 */
     if (Size == 1)
     {
       sum += *(unsigned char *)p;
     }
     
     /* 进位加法 */
     while ((sum >> 16) > 0)
     {
        sum = (sum & 0xff) + (sum >> 16);           
     }
            
     return ~(unsigned short)sum;
     
   }
   ```

   ​

