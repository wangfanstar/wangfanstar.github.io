---
title: Linux I/O系统之一--I/O模型
tags: [linux]
category: 编程
date: 2018-05-18 20:38:07
---

## I/O模型

linux对应的IO一般分为三种类型，字符型，块设备，网络型。这三种的典型代表是串口，硬盘，socket网络。linux本着一切皆文件的思想，对这三种IO设备都当成文件处理。对三种IO有读写（收发）处理。而读写处理中，就有速度的不同。根据处理类型的不同，程序运行有CPU消耗型和IO消耗型。IO消耗型操作占用CPU较少，但往往花费时间较多，比如硬盘读写文件的操作，很多地方是用DMA来进行的。CPU设置好后，剩下的工作就交到DMA处理，等DMA把数据操作完成后再通知CPU处理后续的事件。

## 多事件处理方案

在正常程序流程中，我们按预定的方案将要实现的事件进行编码，在代码中实现所有的事件处理。总结下有如下几种方案

### 顺序处理

最简单的方案是将所有的事件全部罗列出来，event1, event2, event3... 然后在代码中依次执行如下所示：

```c
int main()
{
    event1;  //执行事件1
    event2;  //执行事件2
    event3;  //执行事件3
    return;
}
```

这种方法的优点是实现简单，缺点是可能会造成时间上的浪费，比如如果event2是IO消耗型事件耗时较长但占用CPU较少，虽然CPU没有用，在程序中还是会一直等event2执行完成后才进行event3的处理。造成了CPU空闲浪费的情况，于是我们为了利用CPU，很容易想出另一种方案：多进程，多线程处理

### 多进程多线程处理

此方案的思路是将事件分别在不同的线程上，不同的线程可以在不同的核上运行，相当于并行处理。也可以在同一个核上处理，同一个核上IO消耗型事件运行时，CPU可以调度其他线程，不会空等造成CPU的浪费。

```c
int main()
{
    pthread_create(event1);
    pthread_create(event2);
    pthread_create(event3);
    wait(NULL);
    return;
}
```

多进程多线程的方法让事件可以并行处理，但也有个缺陷是多进程多线程会占用大量的资源，为了节省资源，我们于是想出在单个线程上多路复用的方法。

### 单线程多路复用处理

多路复用的设计相当于在一个线程上同时监听3个事件，哪个事件发生就执行哪个事件的处理。其Linux多路复用的机制发展有以下方案：select, epoll, libevent。其中select是将文件描述符加入到要注意的描述符群中，当有事件发生时，将所有的描述符检查一遍，找出有事件的描述符进行相应的处理。select的不足有两个地方：一是加入描述符时，每次都必须把所有的描述符重新加入一遍，没有记住之前加入的描述符；二是有事件发生后需要扫描一下全部的描述符来检测到底是哪个描述符发生了事件。epoll改进了这两点，使用epoll后每次只需添加所需的描述符，不用再全部描述符重输一遍，二是事件发生后直接通知发生了事件的描述符，不用再遍历查询一遍。libevent机制则是封装了epoll的架构，在不同的系统的提供了相同的接口，同时把回调函数绑定在事件发生的描述符上，当事件发生时自动调用回调函数，达到类似MFC上之类的事件机制。

```c
int main()
{
    epoll_ctl(event1); // 加入监听描述符
    epoll_ctl(event2); // 加入监听描述符
    epoll_ctl(event3); // 加入监听描述符
    while(1){
            epoll_wait(); //等待事件发生
    }
    return;
}
```

### 多事件处理的更多技巧

> 1、在频繁有事件发生情况下，epoll的进程切换开销也可以省下，用定长队列的方式，每次处理完事件后直接处理下一个，不直接调度来实现节省进程切换的开销。在另一篇FIFO的文章将详细再讲述
>
> 2、aio异步IO机制linux用户态采多进程的方式来实现，内核态实现得不太好，好像是效果不行，提供了相关的api，但用得比较少。
>
> 3、SIGIO机制，是Linux上通过信号上绑定事件来实现，linux说是有过度设计的缺陷，用得比较少。





